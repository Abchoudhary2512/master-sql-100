## 76. Rank products by sales within each category using RANK()

```sql
WITH ProductSales AS (
    SELECT 
        p.category_id, 
        p.product_id, 
        p.product_name,
        SUM(oi.quantity * oi.price) AS total_sales
    FROM Products p
    LEFT JOIN Order_Items oi 
        ON p.product_id = oi.product_id
    GROUP BY 
        p.category_id, 
        p.product_id, 
        p.product_name
)
SELECT 
    c.category_name, 
    ps.product_name, 
    ROUND(ps.total_sales, 2) AS total_sales,
    RANK() OVER (
        PARTITION BY ps.category_id 
        ORDER BY ps.total_sales DESC
    ) AS sales_rank
FROM ProductSales ps
JOIN Categories c 
    ON ps.category_id = c.category_id
WHERE ps.total_sales IS NOT NULL
ORDER BY c.category_name, sales_rank;
````

---

## 77. Calculate running total of revenue by month with cumulative sum

```sql
WITH MonthlyRevenue AS (
    SELECT 
        DATE_FORMAT(order_date, '%Y-%m') AS month,
        SUM(total_amount) AS monthly_revenue
    FROM Orders
    WHERE status = 'Delivered'
    GROUP BY month
)
SELECT 
    month, 
    monthly_revenue,
    SUM(monthly_revenue) OVER (ORDER BY month) AS cumulative_revenue,
    ROUND(
        100.0 * SUM(monthly_revenue) OVER (ORDER BY month) 
        / SUM(monthly_revenue) OVER (), 
        2
    ) AS cumulative_percentage
FROM MonthlyRevenue
ORDER BY month;
```

---

## 78. Find the top 3 customers by spend in each month

```sql
WITH MonthlyCustomerSpend AS (
    SELECT 
        DATE_FORMAT(o.order_date, '%Y-%m') AS month,
        c.customer_id, 
        c.first_name, 
        c.last_name,
        SUM(o.total_amount) AS monthly_spend
    FROM Orders o
    JOIN Customers c 
        ON o.customer_id = c.customer_id
    WHERE o.status = 'Delivered'
    GROUP BY 
        month, 
        c.customer_id, 
        c.first_name, 
        c.last_name
),
RankedCustomers AS (
    SELECT *,
        ROW_NUMBER() OVER (
            PARTITION BY month 
            ORDER BY monthly_spend DESC
        ) AS rank_num
    FROM MonthlyCustomerSpend
)
SELECT 
    month, 
    rank_num, 
    first_name, 
    last_name, 
    monthly_spend
FROM RankedCustomers
WHERE rank_num <= 3
ORDER BY month, rank_num;
```

---

## 79. Show each product's sales compared to previous month using LAG

```sql
WITH MonthlyProductSales AS (
    SELECT 
        p.product_id, 
        p.product_name,
        DATE_FORMAT(o.order_date, '%Y-%m') AS month,
        SUM(oi.quantity * oi.price) AS product_sales
    FROM Products p
    JOIN Order_Items oi 
        ON p.product_id = oi.product_id
    JOIN Orders o 
        ON oi.order_id = o.order_id
    WHERE o.status = 'Delivered'
    GROUP BY 
        p.product_id, 
        p.product_name, 
        month
)
SELECT 
    product_name, 
    month, 
    ROUND(product_sales, 2) AS current_sales,
    ROUND(
        LAG(product_sales) OVER (
            PARTITION BY product_id 
            ORDER BY month
        ), 
        2
    ) AS prev_month_sales,
    ROUND(
        product_sales - LAG(product_sales) OVER (
            PARTITION BY product_id 
            ORDER BY month
        ), 
        2
    ) AS sales_change,
    CASE 
        WHEN LAG(product_sales) OVER (PARTITION BY product_id ORDER BY month) IS NULL THEN 'N/A'
        WHEN product_sales > LAG(product_sales) OVER (PARTITION BY product_id ORDER BY month) THEN '↑ Increase'
        WHEN product_sales < LAG(product_sales) OVER (PARTITION BY product_id ORDER BY month) THEN '↓ Decrease'
        ELSE '→ No change'
    END AS trend
FROM MonthlyProductSales
ORDER BY product_name, month;
```

---

## 80. Calculate year-over-year growth by month

```sql
WITH MonthlyRevenue AS (
    SELECT 
        YEAR(order_date) AS year,
        MONTH(order_date) AS month,
        SUM(total_amount) AS revenue
    FROM Orders
    WHERE status = 'Delivered'
    GROUP BY 
        YEAR(order_date), 
        MONTH(order_date)
)
SELECT 
    CONCAT(year, '-', LPAD(month, 2, '0')) AS year_month,
    revenue,
    LAG(revenue) OVER (
        PARTITION BY month 
        ORDER BY year
    ) AS prev_year_revenue,
    CASE 
        WHEN LAG(revenue) OVER (PARTITION BY month ORDER BY year) IS NOT NULL 
        THEN CONCAT(
            ROUND(
                100.0 * (revenue - LAG(revenue) OVER (PARTITION BY month ORDER BY year)) 
                / LAG(revenue) OVER (PARTITION BY month ORDER BY year), 
                2
            ), 
            '%'
        )
        ELSE 'N/A'
    END AS yoy_growth
FROM MonthlyRevenue
ORDER BY year, month;
```

---

## 81. Determine each customer's order percentile based on order value

```sql
WITH CustomerOrderPercentiles AS (
    SELECT 
        c.customer_id, 
        c.first_name, 
        c.last_name,
        o.order_id, 
        o.total_amount,
        NTILE(100) OVER (ORDER BY o.total_amount) AS percentile_rank,
        PERCENT_RANK() OVER (ORDER BY o.total_amount) AS percent_rank_value
    FROM Customers c
    JOIN Orders o 
        ON c.customer_id = o.customer_id
    WHERE o.status = 'Delivered'
)
SELECT 
    customer_id, 
    first_name, 
    last_name, 
    order_id, 
    total_amount,
    percentile_rank,
    ROUND(percent_rank_value * 100, 2) AS percent_rank
FROM CustomerOrderPercentiles
ORDER BY total_amount DESC
LIMIT 10;
```

---

## 82. Find the first and last order date for each customer using FIRST_VALUE / LAST_VALUE

```sql
WITH CustomerOrders AS (
    SELECT 
        c.customer_id, 
        c.first_name, 
        c.last_name,
        o.order_id, 
        o.order_date, 
        o.total_amount,
        FIRST_VALUE(o.order_date) OVER (
            PARTITION BY c.customer_id 
            ORDER BY o.order_date
        ) AS first_order_date,
        LAST_VALUE(o.order_date) OVER (
            PARTITION BY c.customer_id 
            ORDER BY o.order_date 
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) AS last_order_date
    FROM Customers c
    JOIN Orders o 
        ON c.customer_id = o.customer_id
)
SELECT DISTINCT 
    customer_id, 
    first_name, 
    last_name,
    first_order_date, 
    last_order_date,
    DATEDIFF(last_order_date, first_order_date) AS customer_lifetime_days
FROM CustomerOrders
ORDER BY customer_lifetime_days DESC;
```

---

## 83. Calculate median order value using percentile functions

```sql
WITH OrderValues AS (
    SELECT 
        total_amount,
        ROW_NUMBER() OVER (ORDER BY total_amount) AS row_num,
        COUNT(*) OVER () AS total_count
    FROM Orders
    WHERE status = 'Delivered'
)
SELECT 
    AVG(total_amount) AS median_order_value
FROM OrderValues
WHERE row_num IN (
    FLOOR((total_count + 1) / 2), 
    CEIL((total_count + 1) / 2)
);
```

---

## 84. Show customer ranking changes over time

```sql
WITH MonthlyCustomerRanking AS (
    SELECT 
        c.customer_id, 
        c.first_name, 
        c.last_name,
        DATE_FORMAT(o.order_date, '%Y-%m') AS month,
        SUM(o.total_amount) AS monthly_spend,
        RANK() OVER (
            PARTITION BY DATE_FORMAT(o.order_date, '%Y-%m') 
            ORDER BY SUM(o.total_amount) DESC
        ) AS monthly_rank
    FROM Customers c
    JOIN Orders o 
        ON c.customer_id = o.customer_id
    WHERE o.status = 'Delivered'
    GROUP BY 
        c.customer_id, 
        c.first_name, 
        c.last_name, 
        month
)
SELECT 
    customer_id, 
    first_name, 
    last_name, 
    month, 
    monthly_spend, 
    monthly_rank,
    LAG(monthly_rank) OVER (
        PARTITION BY customer_id 
        ORDER BY month
    ) AS prev_month_rank,
    CASE 
        WHEN LAG(monthly_rank) OVER (PARTITION BY customer_id ORDER BY month) IS NOT NULL
        THEN monthly_rank - LAG(monthly_rank) OVER (PARTITION BY customer_id ORDER BY month)
        ELSE NULL
    END AS rank_change
FROM MonthlyCustomerRanking
WHERE monthly_rank <= 5
ORDER BY month, monthly_rank;
```

---

## 85. Identify products with declining sales (3-month negative trend)

```sql
WITH MonthlyProductSales AS (
    SELECT 
        p.product_id, 
        p.product_name,
        DATE_FORMAT(o.order_date, '%Y-%m') AS month,
        SUM(oi.quantity) AS quantity_sold
    FROM Products p
    JOIN Order_Items oi 
        ON p.product_id = oi.product_id
    JOIN Orders o 
        ON oi.order_id = o.order_id
    WHERE o.status = 'Delivered'
    GROUP BY 
        p.product_id, 
        p.product_name, 
        month
),
SalesWithTrend AS (
    SELECT 
        product_id, 
        product_name, 
        month, 
        quantity_sold,
        LAG(quantity_sold, 1) OVER (PARTITION BY product_id ORDER BY month) AS prev_month_1,
        LAG(quantity_sold, 2) OVER (PARTITION BY product_id ORDER BY month) AS prev_month_2
    FROM MonthlyProductSales
)
SELECT 
    product_name, 
    GROUP_CONCAT(month ORDER BY month) AS months,
    GROUP_CONCAT(quantity_sold ORDER BY month) AS sales_trend
FROM SalesWithTrend
WHERE quantity_sold < prev_month_1 
  AND prev_month_1 < prev_month_2
GROUP BY product_id, product_name;
```

---

## 86. Calculate customer lifetime value considering repeat purchases

```sql
WITH CustomerMetrics AS (
    SELECT 
        c.customer_id, 
        c.first_name, 
        c.last_name,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(o.total_amount) AS total_spent,
        MIN(o.order_date) AS first_order,
        MAX(o.order_date) AS last_order,
        AVG(o.total_amount) AS avg_order_value
    FROM Customers c
    LEFT JOIN Orders o 
        ON c.customer_id = o.customer_id 
       AND o.status = 'Delivered'
    GROUP BY 
        c.customer_id, 
        c.first_name, 
        c.last_name
    HAVING total_orders > 0
)
SELECT 
    customer_id, 
    first_name, 
    last_name,
    total_orders, 
    ROUND(total_spent, 2) AS total_spent,
    ROUND(avg_order_value, 2) AS avg_order_value,
    DATEDIFF(last_order, first_order) AS customer_lifetime_days,
    ROUND(
        total_spent / NULLIF(DATEDIFF(last_order, first_order), 0) * 365, 
        2
    ) AS projected_annual_value,
    CASE 
        WHEN total_orders = 1 THEN 'One-time Buyer'
        WHEN total_orders <= 2 THEN 'Occasional Buyer'
        ELSE 'Frequent Buyer'
    END AS buyer_type
FROM CustomerMetrics
ORDER BY projected_annual_value DESC;
```

---

## 87. Determine cohort retention analysis – percentage of customers returning each month

```sql
WITH CohortData AS (
    SELECT 
        c.customer_id,
        DATE_FORMAT(MIN(o.order_date), '%Y-%m') AS cohort_month
    FROM Customers c
    JOIN Orders o 
        ON c.customer_id = o.customer_id
    GROUP BY c.customer_id
),
CohortActivity AS (
    SELECT 
        cd.cohort_month,
        DATE_FORMAT(o.order_date, '%Y-%m') AS activity_month,
        COUNT(DISTINCT cd.customer_id) AS customers
    FROM CohortData cd
    JOIN Orders o 
        ON cd.customer_id = o.customer_id
    GROUP BY 
        cd.cohort_month, 
        activity_month
)
SELECT 
    cohort_month,
    SUM(CASE WHEN activity_month = cohort_month THEN customers ELSE 0 END) AS month_0,
    SUM(CASE WHEN activity_month = DATE_FORMAT(DATE_ADD(STR_TO_DATE(CONCAT(cohort_month, '-01'), '%Y-%m-%d'), INTERVAL 1 MONTH), '%Y-%m') THEN customers ELSE 0 END) AS month_1,
    SUM(CASE WHEN activity_month = DATE_FORMAT(DATE_ADD(STR_TO_DATE(CONCAT(cohort_month, '-01'), '%Y-%m-%d'), INTERVAL 2 MONTH), '%Y-%m') THEN customers ELSE 0 END) AS month_2,
    SUM(CASE WHEN activity_month = DATE_FORMAT(DATE_ADD(STR_TO_DATE(CONCAT(cohort_month, '-01'), '%Y-%m-%d'), INTERVAL 3 MONTH), '%Y-%m') THEN customers ELSE 0 END) AS month_3
FROM CohortActivity
GROUP BY cohort_month
ORDER BY cohort_month;
```

---

## 88. Find products with highest cross-sell potential

```sql
WITH ProductPairs AS (
    SELECT 
        oi1.product_id AS product_a,
        oi2.product_id AS product_b,
        COUNT(*) AS times_bought_together
    FROM Order_Items oi1
    JOIN Order_Items oi2 
        ON oi1.order_id = oi2.order_id 
       AND oi1.product_id < oi2.product_id
    GROUP BY 
        oi1.product_id, 
        oi2.product_id
),
ProductPurchaseCount AS (
    SELECT 
        product_id, 
        COUNT(DISTINCT order_id) AS purchase_count
    FROM Order_Items
    GROUP BY product_id
),
CrossSellScore AS (
    SELECT 
        pp.product_a, 
        pp.product_b, 
        pp.times_bought_together,
        ROUND(100.0 * pp.times_bought_together / ppc1.purchase_count, 2) AS percentage_of_a_orders,
        ROUND(100.0 * pp.times_bought_together / ppc2.purchase_count, 2) AS percentage_of_b_orders
    FROM ProductPairs pp
    JOIN ProductPurchaseCount ppc1 
        ON pp.product_a = ppc1.product_id
    JOIN ProductPurchaseCount ppc2 
        ON pp.product_b = ppc2.product_id
)
SELECT 
    p1.product_name AS product_a, 
    p2.product_name AS product_b,
    cs.times_bought_together,
    cs.percentage_of_a_orders AS pct_a_also_bought_b,
    cs.percentage_of_b_orders AS pct_b_also_bought_a
FROM CrossSellScore cs
JOIN Products p1 
    ON cs.product_a = p1.product_id
JOIN Products p2 
    ON cs.product_b = p2.product_id
WHERE cs.times_bought_together >= 1
ORDER BY cs.times_bought_together DESC
LIMIT 5;
```

---

## 89. Calculate shopping cart abandonment rate

```sql
WITH OrderStatus AS (
    SELECT 
        status, 
        COUNT(*) AS order_count
    FROM Orders
    GROUP BY status
),
TotalOrders AS (
    SELECT 
        SUM(order_count) AS total 
    FROM OrderStatus
)
SELECT 
    os.status, 
    os.order_count,
    ROUND(100.0 * os.order_count / tot.total, 2) AS percentage,
    CASE 
        WHEN os.status = 'Pending' THEN 'Abandoned Cart'
        WHEN os.status = 'Processing' THEN 'In Progress'
        WHEN os.status IN ('Shipped', 'Delivered') THEN 'Completed'
        WHEN os.status = 'Cancelled' THEN 'Abandoned Cart'
        ELSE 'Other'
    END AS funnel_stage
FROM OrderStatus os
CROSS JOIN TotalOrders tot
ORDER BY 
    CASE funnel_stage
        WHEN 'Completed' THEN 1
        WHEN 'In Progress' THEN 2
        WHEN 'Abandoned Cart' THEN 3
    END;
```

---

## 90. Identify seasonal trends by category

```sql
WITH MonthlyCategorySales AS (
    SELECT 
        c.category_id, 
        c.category_name,
        MONTH(o.order_date) AS month_num,
        DATE_FORMAT(o.order_date, '%b') AS month_name,
        SUM(oi.quantity * oi.price) AS monthly_sales
    FROM Categories c
    JOIN Products p 
        ON c.category_id = p.category_id
    JOIN Order_Items oi 
        ON p.product_id = oi.product_id
    JOIN Orders o 
        ON oi.order_id = o.order_id
    WHERE o.status = 'Delivered'
    GROUP BY 
        c.category_id, 
        c.category_name, 
        month_num, 
        month_name
),
CategoryAvg AS (
    SELECT 
        category_id, 
        category_name,
        AVG(monthly_sales) AS avg_monthly_sales
    FROM MonthlyCategorySales
    GROUP BY 
        category_id, 
        category_name
)
SELECT 
    mcs.category_name, 
    mcs.month_name, 
    ROUND(mcs.monthly_sales, 2) AS sales,
    ROUND(ca.avg_monthly_sales, 2) AS avg_sales,
    ROUND(
        100.0 * (mcs.monthly_sales - ca.avg_monthly_sales) 
        / ca.avg_monthly_sales, 
        2
    ) AS pct_above_avg,
    CASE 
        WHEN mcs.monthly_sales > ca.avg_monthly_sales * 1.2 THEN 'PEAK SEASON'
        WHEN mcs.monthly_sales < ca.avg_monthly_sales * 0.8 THEN 'OFF SEASON'
        ELSE 'NORMAL'
    END AS seasonality
FROM MonthlyCategorySales mcs
JOIN CategoryAvg ca 
    ON mcs.category_id = ca.category_id
ORDER BY 
    mcs.category_name, 
    mcs.month_num;
```

---
