
## 91. Generate a calendar table for 2024 with all dates

```sql
WITH RECURSIVE Calendar AS (
    SELECT DATE('2024-01-01') AS date
    UNION ALL
    SELECT DATE_ADD(date, INTERVAL 1 DAY)
    FROM Calendar
    WHERE date < '2024-12-31'
)
SELECT 
    date, 
    DAYOFWEEK(date) AS day_of_week,
    DAYNAME(date) AS day_name,
    MONTH(date) AS month,
    MONTHNAME(date) AS month_name,
    QUARTER(date) AS quarter,
    WEEK(date) AS week_number
FROM Calendar
ORDER BY date
LIMIT 10;
```

---

## 92. Find customers who bought product A but not product B

```sql
-- Example: Customers who bought Laptop but not Smartphone
SELECT DISTINCT 
    c.customer_id, 
    c.first_name, 
    c.last_name, 
    c.email
FROM Customers c
JOIN Orders o 
    ON c.customer_id = o.customer_id
JOIN Order_Items oi 
    ON o.order_id = oi.order_id
JOIN Products p 
    ON oi.product_id = p.product_id
WHERE p.product_name LIKE '%Laptop%'
AND c.customer_id NOT IN (
    SELECT DISTINCT c2.customer_id
    FROM Customers c2
    JOIN Orders o2 
        ON c2.customer_id = o2.customer_id
    JOIN Order_Items oi2 
        ON o2.order_id = oi2.order_id
    JOIN Products p2 
        ON oi2.product_id = p2.product_id
    WHERE p2.product_name LIKE '%Smartphone%'
);
```

---

## 93. Calculate days between orders for repeat customers

```sql
WITH CustomerOrders AS (
    SELECT 
        customer_id, 
        order_id, 
        order_date,
        LEAD(order_date) OVER (
            PARTITION BY customer_id 
            ORDER BY order_date
        ) AS next_order_date
    FROM Orders
    WHERE status = 'Delivered'
),
OrderGaps AS (
    SELECT 
        customer_id, 
        order_id, 
        order_date, 
        next_order_date,
        DATEDIFF(next_order_date, order_date) AS days_until_next_order
    FROM CustomerOrders
    WHERE next_order_date IS NOT NULL
)
SELECT 
    c.customer_id, 
    c.first_name, 
    c.last_name,
    AVG(og.days_until_next_order) AS avg_days_between_orders,
    MIN(og.days_until_next_order) AS min_days_between_orders,
    MAX(og.days_until_next_order) AS max_days_between_orders,
    STDDEV(og.days_until_next_order) AS stddev_days_between_orders
FROM OrderGaps og
JOIN Customers c 
    ON og.customer_id = c.customer_id
GROUP BY 
    c.customer_id, 
    c.first_name, 
    c.last_name
ORDER BY avg_days_between_orders;
```

---

## 94. Identify best-performing sales channels (payment methods)

```sql
WITH PaymentPerformance AS (
    SELECT 
        p.payment_method,
        COUNT(*) AS total_transactions,
        SUM(CASE WHEN p.payment_status = 'Completed' THEN 1 ELSE 0 END) AS successful_transactions,
        SUM(CASE WHEN p.payment_status = 'Completed' THEN p.amount ELSE 0 END) AS successful_amount,
        AVG(p.amount) AS avg_transaction_value
    FROM Payments p
    GROUP BY p.payment_method
)
SELECT 
    payment_method,
    total_transactions,
    successful_transactions,
    ROUND(100.0 * successful_transactions / total_transactions, 2) AS success_rate,
    ROUND(successful_amount, 2) AS revenue_generated,
    ROUND(avg_transaction_value, 2) AS avg_transaction_value,
    RANK() OVER (ORDER BY successful_amount DESC) AS revenue_rank,
    RANK() OVER (ORDER BY success_rate DESC) AS reliability_rank
FROM PaymentPerformance
ORDER BY revenue_rank;
```

---

## 95. Find customers with irregular purchasing patterns

```sql
WITH CustomerStats AS (
    SELECT 
        c.customer_id, 
        c.first_name, 
        c.last_name,
        COUNT(o.order_id) AS order_count,
        AVG(o.total_amount) AS avg_order_value,
        STDDEV(o.total_amount) AS stddev_order_value,
        MIN(o.total_amount) AS min_order,
        MAX(o.total_amount) AS max_order
    FROM Customers c
    JOIN Orders o 
        ON c.customer_id = o.customer_id
    WHERE o.status = 'Delivered'
    GROUP BY 
        c.customer_id, 
        c.first_name, 
        c.last_name
    HAVING COUNT(o.order_id) >= 2
)
SELECT 
    customer_id, 
    first_name, 
    last_name,
    order_count, 
    ROUND(avg_order_value, 2) AS avg_order_value,
    ROUND(stddev_order_value, 2) AS stddev_order_value,
    ROUND(min_order, 2) AS min_order, 
    ROUND(max_order, 2) AS max_order,
    ROUND(max_order / NULLIF(min_order, 0), 2) AS max_min_ratio,
    CASE 
        WHEN stddev_order_value > avg_order_value * 0.5 THEN 'High Variability'
        WHEN max_order / NULLIF(min_order, 0) > 3 THEN 'Extreme Range'
        ELSE 'Regular Pattern'
    END AS purchasing_pattern
FROM CustomerStats
WHERE stddev_order_value > avg_order_value * 0.5 
   OR max_order / NULLIF(min_order, 0) > 3
ORDER BY stddev_order_value DESC;
```

---

## 96. Calculate inventory turnover rate by category

```sql
WITH CategorySales AS (
    SELECT 
        p.category_id,
        SUM(oi.quantity) AS units_sold
    FROM Order_Items oi
    JOIN Products p 
        ON oi.product_id = p.product_id
    JOIN Orders o 
        ON oi.order_id = o.order_id
    WHERE o.status = 'Delivered'
    GROUP BY p.category_id
),
CategoryInventory AS (
    SELECT 
        category_id,
        SUM(stock) AS total_stock,
        AVG(price) AS avg_price
    FROM Products
    GROUP BY category_id
)
SELECT 
    c.category_name,
    ci.total_stock AS current_inventory,
    COALESCE(cs.units_sold, 0) AS units_sold,
    ROUND(COALESCE(cs.units_sold, 0) / NULLIF(ci.total_stock, 0) * 100, 2) AS turnover_rate_pct,
    CASE 
        WHEN COALESCE(cs.units_sold, 0) / NULLIF(ci.total_stock, 0) > 0.5 THEN 'High Turnover'
        WHEN COALESCE(cs.units_sold, 0) / NULLIF(ci.total_stock, 0) > 0.2 THEN 'Medium Turnover'
        ELSE 'Low Turnover'
    END AS turnover_category
FROM Categories c
LEFT JOIN CategoryInventory ci 
    ON c.category_id = ci.category_id
LEFT JOIN CategorySales cs 
    ON c.category_id = cs.category_id
ORDER BY turnover_rate_pct DESC;
```

---

## 97. Find optimal product bundles based on order history

```sql
WITH ProductPairs AS (
    SELECT 
        oi1.product_id AS p1, 
        oi2.product_id AS p2, 
        COUNT(*) AS frequency
    FROM Order_Items oi1
    JOIN Order_Items oi2 
        ON oi1.order_id = oi2.order_id 
       AND oi1.product_id < oi2.product_id
    GROUP BY oi1.product_id, oi2.product_id
    HAVING COUNT(*) >= 1
),
ProductPrices AS (
    SELECT product_id, price FROM Products
)
SELECT 
    CONCAT(pr1.product_name, ' + ', pr2.product_name) AS bundle,
    pp.frequency AS times_bought_together,
    ROUND(p1.price + p2.price, 2) AS combined_price,
    ROUND((p1.price + p2.price) * 0.9, 2) AS discounted_bundle_price,
    ROUND((p1.price + p2.price) * 0.1, 2) AS savings
FROM ProductPairs pp
JOIN Products pr1 
    ON pp.p1 = pr1.product_id
JOIN Products pr2 
    ON pp.p2 = pr2.product_id
JOIN ProductPrices p1 
    ON pp.p1 = p1.product_id
JOIN ProductPrices p2 
    ON pp.p2 = p2.product_id
ORDER BY pp.frequency DESC, combined_price DESC
LIMIT 5;
```

---

## 98. Identify products with highest repeat purchase rate

```sql
WITH ProductCustomerOrders AS (
    SELECT 
        p.product_id, 
        p.product_name,
        o.customer_id,
        COUNT(DISTINCT o.order_id) AS times_ordered_by_customer
    FROM Products p
    JOIN Order_Items oi 
        ON p.product_id = oi.product_id
    JOIN Orders o 
        ON oi.order_id = o.order_id
    WHERE o.status = 'Delivered'
    GROUP BY 
        p.product_id, 
        p.product_name, 
        o.customer_id
),
RepeatStats AS (
    SELECT 
        product_id, 
        product_name,
        COUNT(*) AS total_customers,
        SUM(CASE WHEN times_ordered_by_customer > 1 THEN 1 ELSE 0 END) AS repeat_customers,
        AVG(times_ordered_by_customer) AS avg_orders_per_customer
    FROM ProductCustomerOrders
    GROUP BY product_id, product_name
)
SELECT 
    product_name,
    total_customers,
    repeat_customers,
    ROUND(100.0 * repeat_customers / total_customers, 2) AS repeat_rate,
    ROUND(avg_orders_per_customer, 2) AS avg_orders_per_customer
FROM RepeatStats
WHERE total_customers >= 2
ORDER BY repeat_rate DESC, total_customers DESC;
```

---

## 99. Find customers at risk of churn

```sql
WITH CustomerLastOrder AS (
    SELECT 
        c.customer_id, 
        c.first_name, 
        c.last_name, 
        c.email,
        MAX(o.order_date) AS last_order_date,
        COUNT(o.order_id) AS total_orders,
        SUM(o.total_amount) AS total_spent
    FROM Customers c
    LEFT JOIN Orders o 
        ON c.customer_id = o.customer_id 
       AND o.status = 'Delivered'
    GROUP BY 
        c.customer_id, 
        c.first_name, 
        c.last_name, 
        c.email
    HAVING MAX(o.order_date) IS NOT NULL
)
SELECT 
    customer_id, 
    first_name, 
    last_name, 
    email,
    last_order_date,
    DATEDIFF(CURDATE(), last_order_date) AS days_since_last_order,
    total_orders, 
    ROUND(total_spent, 2) AS total_spent,
    CASE 
        WHEN DATEDIFF(CURDATE(), last_order_date) > 60 THEN 'HIGH RISK - Churned'
        WHEN DATEDIFF(CURDATE(), last_order_date) > 30 THEN 'MEDIUM RISK - At Risk'
        ELSE 'LOW RISK - Active'
    END AS churn_risk,
    CASE 
        WHEN total_orders = 1 THEN 'One-time Buyer'
        ELSE 'Repeat Buyer'
    END AS buyer_type
FROM CustomerLastOrder
ORDER BY days_since_last_order DESC;
```

---

## 100. Build complete customer 360 view

```sql
WITH CustomerSummary AS (
    SELECT 
        c.customer_id, 
        c.first_name, 
        c.last_name, 
        c.email, 
        c.phone, 
        c.created_at,
        COUNT(DISTINCT o.order_id) AS total_orders,
        COUNT(DISTINCT CASE WHEN o.status = 'Delivered' THEN o.order_id END) AS completed_orders,
        SUM(CASE WHEN o.status = 'Delivered' THEN o.total_amount ELSE 0 END) AS lifetime_value,
        AVG(CASE WHEN o.status = 'Delivered' THEN o.total_amount END) AS avg_order_value,
        MIN(CASE WHEN o.status = 'Delivered' THEN o.order_date END) AS first_order_date,
        MAX(CASE WHEN o.status = 'Delivered' THEN o.order_date END) AS last_order_date,
        COUNT(DISTINCT a.address_id) AS total_addresses,
        COUNT(DISTINCT CASE WHEN a.address_type = 'Shipping' THEN a.address_id END) AS shipping_addresses,
        COUNT(DISTINCT CASE WHEN a.address_type = 'Billing' THEN a.address_id END) AS billing_addresses
    FROM Customers c
    LEFT JOIN Orders o 
        ON c.customer_id = o.customer_id
    LEFT JOIN Addresses a 
        ON c.customer_id = a.customer_id
    GROUP BY 
        c.customer_id, 
        c.first_name, 
        c.last_name, 
        c.email, 
        c.phone, 
        c.created_at
),
FavoriteCategory AS (
    SELECT 
        c.customer_id, 
        cat.category_name,
        COUNT(*) AS category_purchases,
        ROW_NUMBER() OVER (
            PARTITION BY c.customer_id 
            ORDER BY COUNT(*) DESC
        ) AS rn
    FROM Customers c
    JOIN Orders o 
        ON c.customer_id = o.customer_id
    JOIN Order_Items oi 
        ON o.order_id = oi.order_id
    JOIN Products p 
        ON oi.product_id = p.product_id
    JOIN Categories cat 
        ON p.category_id = cat.category_id
    WHERE o.status = 'Delivered'
    GROUP BY 
        c.customer_id, 
        cat.category_name
),
PaymentPreference AS (
    SELECT 
        o.customer_id, 
        p.payment_method,
        COUNT(*) AS method_usage,
        ROW_NUMBER() OVER (
            PARTITION BY o.customer_id 
            ORDER BY COUNT(*) DESC
        ) AS rn
    FROM Payments p
    JOIN Orders o 
        ON p.order_id = o.order_id
    WHERE p.payment_status = 'Completed'
    GROUP BY 
        o.customer_id, 
        p.payment_method
)
SELECT 
    cs.customer_id, 
    cs.first_name, 
    cs.last_name, 
    cs.email, 
    cs.phone,
    DATE(cs.created_at) AS registration_date,
    cs.total_orders, 
    cs.completed_orders, 
    ROUND(cs.lifetime_value, 2) AS lifetime_value,
    ROUND(cs.avg_order_value, 2) AS avg_order_value,
    cs.first_order_date, 
    cs.last_order_date,
    DATEDIFF(
        COALESCE(cs.last_order_date, CURDATE()), 
        cs.first_order_date
    ) AS customer_lifetime_days,
    cs.total_addresses, 
    cs.shipping_addresses, 
    cs.billing_addresses,
    fc.category_name AS favorite_category,
    pp.payment_method AS preferred_payment,
    CASE 
        WHEN cs.lifetime_value > 1000 THEN 'VIP'
        WHEN cs.lifetime_value > 500 THEN 'Gold'
        WHEN cs.lifetime_value > 100 THEN 'Silver'
        ELSE 'Bronze'
    END AS customer_tier,
    CASE 
        WHEN cs.completed_orders = 0 THEN 'Inactive'
        WHEN cs.completed_orders = 1 THEN 'New'
        WHEN cs.completed_orders <= 3 THEN 'Active'
        ELSE 'Loyal'
    END AS customer_status
FROM CustomerSummary cs
LEFT JOIN FavoriteCategory fc 
    ON cs.customer_id = fc.customer_id 
   AND fc.rn = 1
LEFT JOIN PaymentPreference pp 
    ON cs.customer_id = pp.customer_id 
   AND pp.rn = 1
ORDER BY cs.lifetime_value DESC;
```
